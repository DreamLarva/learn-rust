// 宏(Macro) 指的是 Rust中一系列的功能: 使用macro_rules!的声明(Declarative)宏,
// 和 三种过程 (Procedural)宏
//  自定义 #[derive]宏在结构体和枚举上指定通过 derive 属性添加代码
//  类属性(Attribute-like)宏定义可以用于任何项的自定义属性
//  类函数宏看起来像函数 不过作用域作为参数传递的token

// 宏和函数的区别
// 从根本上来说,宏是一个为写其他代码而写代码的方式,即所谓的 元编程(metaprogramming).
// print!宏 和 vec!宏,这些以宏的 展开的方式来生成比你手写出代码更多的diamante.

// 元编程对于减少大量编写和维护的代码非常有用,它也扮演了函数扮演的角色.
// 但宏有一些函数所没有的附加能力
// 一个函数标签必须声明函数参数个数和类型.相比之下,宏能够接受不同数量的参数:
// 用一个参数调用 println!("hello") 或两个参数调用 println!("hello {}",name)
// 而且宏开一在编译前展开,例如宏可以在一个给定类型上实现 trait. 而函数不行,因为函数在运行时调用,同时 trait需要在编译时实现.

// 实现一个宏 而不是一个函数的缺点 是宏定义要比 函数定义 更复杂,因为你在编写生成Rust代码的Rust代码
// 由于这样的间接性,宏定义通常要比函数更加难阅读,理解和维护

// 宏和函数的最后一个重要区别是L在一个文件调用宏之前 必须定义他,或将其引入作用域,而函数则可以在任何地方定义和调用

extern crate proc_macro;

use self::proc_macro::TokenStream;
// quote将syn解析的数据结构转换为Rust代码.
use quote::quote;
// syn crate 将字符串的Rust代码解析成为一个可以操作的数据结构
use syn;

// 使用macro_rules!的声明宏用于通用元编程
// Rust最常用的宏是声明宏.其核心概念是,声明宏允许我们编写一些类似Rust match表达式的代码.
// match表达式是控制结构,其接受一个表达式,与表达式的结果进行模式匹配,然后根据模式匹配执行相关代码.
// 宏也将一个值和包含相关代码的模式进行比较;这种情况下,该值是传递给宏的Rust源代码字面值,
// 模式用于和传递给宏的源代码进行比较;同时每个模式的相关diamante则用于替换传递给宏的代码.所以这一些都发生于编译时.
fn main() {
    vec![1];
}
// vec!宏的简化版
#[macro_export] // #[macro_export] 注解说明宏应该是可用的。 如果没有该注解，这个宏不能被引入作用域。
macro_rules! vec { // 不带感叹号
    // 单边模式 ( $( $x:expr ),* )
    ( $( $x:expr ),* ) => { // 如果模式匹配，该相关代码块将被执行
    // 假设这是这个宏中唯一的模式，则只有这一种有效匹配，其他任何匹配都是错误的。更复杂的宏会有多个单边模式。
    // 宏模式匹配的是 Rust代码结构 而不是值
    // 一对括号包含了整个模式。接下来是美元符号（ $ ），后跟一对括号，捕获了符合括号内模式的值以用于替换后的代码。
    // $() 内则是 $x:expr ，其匹配 Rust 的任意表达式，并将该表达式记作 $x。
    // $()之后的逗号说明一个可有可与的逗号分隔符可以出现在$()所匹配的代码之后.
    // 紧随逗号之后的 * 说明该模式匹配 零个或多个 * 之前的任何模式
    // 当以 vec![1,2,3]调用宏时 $x 魔术与三个表达式1,2,3进行了3次匹配
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };

    // 单边模式相关联的代码块中的模式: 对于每个(在 => 前面)匹配模式中的$()的部分,生成零个或更多个(在=> 后面)位于$()*内的 temp_vec.push()
    // 生成的个数取决于该模式被匹配的次数.
    // $x由每个与之相匹配的表达式所替换. 当以 vec![1,2,3];调用该宏时会生成以下代码

    // let mut temp_vec = Vec::new();
    // temp_vec.push(1);
    // temp_vec.push(2);
    // temp_vec.push(3);
    // temp_vec
}

// 用于属性生成代码的过程宏
// 第二种形式的宏称为 过程宏(procedural macros),因为他们更像函数(一种过程类型).过程宏接受Rust代码作为输入,在这些代码上进行操作,
// 然后产生另一些代码作为输出,而非像声明宏那样匹配对应模式然后以另一部分代码替换当前代码.
// 有三种过程宏(自定义派生(derive),类属性和类函数),不过他们的工作方式类似
// 创建过程宏时,其定义必须驻留在它们自己的具有特殊crate类型的crate中.这么做出于复杂的技术原因,将来我们希望能够消除这些限制.

// 定义一个过程宏

// use proc_macro;
// #[some_attribute]
// pub fn some_name(input: TokenStream) -> TokenStream {}

// 定义过程宏的函数以 TokenStream作为输入并生成TokenStream作为输出.
// TokenStream类型由包含在Rust中的proc_macro crate定义并表示令牌序列
// 这是宏的和兴: 宏所操作的源代码构成了输入TokenStream,宏产生的代码是输出TokenStream.
// 该函数还附加了一个属性,用于指定我们正在创建的程序宏类型.我们可以在同一个crate中拥有多种长须宏

// 代码 见 derive_macro
